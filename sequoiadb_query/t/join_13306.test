
# Test Join
--source suite/sequoiadb_query/include/have_sequoiadb.inc

#
# Initialization
--disable_warnings
drop table if exists table_join_t1,table_join_t2,table_join_t3;
--enable_warnings

#
# Test different join syntaxes
#

CREATE TABLE table_join_t1 (S1 INT);
CREATE TABLE table_join_t2 (S1 INT);
INSERT INTO table_join_t1 VALUES (1);
INSERT INTO table_join_t2 VALUES (2);
SELECT * FROM table_join_t1 JOIN table_join_t2;
SELECT * FROM table_join_t1 INNER JOIN table_join_t2;
SELECT * from table_join_t1 JOIN table_join_t2 USING (S1);
SELECT * FROM table_join_t1 INNER JOIN table_join_t2 USING (S1);
SELECT * from table_join_t1 CROSS JOIN table_join_t2;
SELECT * from table_join_t1 LEFT JOIN table_join_t2 USING(S1);
SELECT * from table_join_t1 LEFT JOIN table_join_t2 ON(table_join_t2.S1=2);
SELECT * from table_join_t1 RIGHT JOIN table_join_t2 USING(S1);
SELECT * from table_join_t1 RIGHT JOIN table_join_t2 ON(table_join_t1.S1=1);
drop table table_join_t1,table_join_t2;

#
# This failed for lia Perminov
#

create table table_join_t1 (id int primary key);
create table table_join_t2 (id int);
insert into table_join_t1 values (75);
insert into table_join_t1 values (79);
insert into table_join_t1 values (78);
insert into table_join_t1 values (77);
replace into table_join_t1 values (76);
#replace into table_join_t1 values (76);
insert into table_join_t1 values (104);
insert into table_join_t1 values (103);
insert into table_join_t1 values (102);
insert into table_join_t1 values (101);
insert into table_join_t1 values (105);
insert into table_join_t1 values (106);
insert into table_join_t1 values (107);

insert into table_join_t2 values (107),(75),(1000);

select table_join_t1.id, table_join_t2.id from table_join_t1, table_join_t2 where table_join_t2.id = table_join_t1.id;
select table_join_t1.id, count(table_join_t2.id) from table_join_t1,table_join_t2 where table_join_t2.id = table_join_t1.id group by table_join_t1.id;
# We see the functional dependency implied by WHERE!
select table_join_t1.id, count(table_join_t2.id) from table_join_t1,table_join_t2 where table_join_t2.id = table_join_t1.id group by table_join_t2.id;

#
# Test problems with impossible ON or WHERE
#
select table_join_t1.id,table_join_t2.id from table_join_t2 left join table_join_t1 on table_join_t1.id>=74 and table_join_t1.id<=0 where table_join_t2.id=75 and table_join_t1.id is null;
explain select table_join_t1.id,table_join_t2.id from table_join_t2 left join table_join_t1 on table_join_t1.id>=74 and table_join_t1.id<=0 where table_join_t2.id=75 and table_join_t1.id is null;
explain select table_join_t1.id, table_join_t2.id from table_join_t1, table_join_t2 where table_join_t2.id = table_join_t1.id and table_join_t1.id <0 and table_join_t1.id > 0;
drop table table_join_t1,table_join_t2;

#
# problem with join
#
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
CREATE TABLE table_join_t1 (
  id int(11) NOT NULL,
  token varchar(100) DEFAULT '' NOT NULL,
  count int(11) DEFAULT '0' NOT NULL,
  qty int(11),
  phone char(1) DEFAULT '' NOT NULL,
  timestamp datetime DEFAULT '0000-00-00 00:00:00' NOT NULL,
  PRIMARY KEY (id),
  KEY token (token(15)),
  UNIQUE token_2 (id, token(75),count,phone)
);
SET sql_mode = default;
INSERT INTO table_join_t1 VALUES (21,'e45703b64de71482360de8fec94c3ade',3,7800,'n','1999-12-23 17:22:21');
INSERT INTO table_join_t1 VALUES (22,'e45703b64de71482360de8fec94c3ade',4,5000,'y','1999-12-23 17:22:21');
INSERT INTO table_join_t1 VALUES (18,'346d1cb63c89285b2351f0ca4de40eda',3,13200,'b','1999-12-23 11:58:04');
INSERT INTO table_join_t1 VALUES (17,'ca6ddeb689e1b48a04146b1b5b6f936a',4,15000,'b','1999-12-23 11:36:53');
INSERT INTO table_join_t1 VALUES (16,'ca6ddeb689e1b48a04146b1b5b6f936a',3,13200,'b','1999-12-23 11:36:53');
INSERT INTO table_join_t1 VALUES (26,'a71250b7ed780f6ef3185bfffe027983',5,1500,'b','1999-12-27 09:44:24');
INSERT INTO table_join_t1 VALUES (24,'4d75906f3c37ecff478a1eb56637aa09',3,5400,'y','1999-12-23 17:29:12');
INSERT INTO table_join_t1 VALUES (25,'4d75906f3c37ecff478a1eb56637aa09',4,6500,'y','1999-12-23 17:29:12');
INSERT INTO table_join_t1 VALUES (27,'a71250b7ed780f6ef3185bfffe027983',3,6200,'b','1999-12-27 09:44:24');
INSERT INTO table_join_t1 VALUES (28,'a71250b7ed780f6ef3185bfffe027983',3,5400,'y','1999-12-27 09:44:36');
INSERT INTO table_join_t1 VALUES (29,'a71250b7ed780f6ef3185bfffe027983',4,17700,'b','1999-12-27 09:45:05');

CREATE TABLE table_join_t2 (
  id int(11) NOT NULL,
  category int(11) DEFAULT '0' NOT NULL,
  county int(11) DEFAULT '0' NOT NULL,
  state int(11) DEFAULT '0' NOT NULL,
  phones int(11) DEFAULT '0' NOT NULL,
  nophones int(11) DEFAULT '0' NOT NULL,
  PRIMARY KEY (id),
  KEY category (category,county,state)
);
INSERT INTO table_join_t2 VALUES (3,2,11,12,5400,7800);
INSERT INTO table_join_t2 VALUES (4,2,25,12,6500,11200);
INSERT INTO table_join_t2 VALUES (5,1,37,6,10000,12000);
select a.id, b.category as catid, b.state as stateid, b.county as countyid from table_join_t1 a, table_join_t2 b ignore index (primary) where (a.token ='a71250b7ed780f6ef3185bfffe027983') and (a.count = b.id);
select a.id, b.category as catid, b.state as stateid, b.county as
countyid from table_join_t1 a, table_join_t2 b where (a.token =
'a71250b7ed780f6ef3185bfffe027983') and (a.count = b.id) order by a.id;

drop table table_join_t1, table_join_t2;

#
# Test of join of many tables.

create table table_join_t1 (a int primary key);
insert into table_join_t1 values(1),(2);
select table_join_t1.a from table_join_t1 as table_join_t1 left join table_join_t1 as table_join_t2 using (a) left join table_join_t1 as table_join_t3 using (a) left join table_join_t1 as table_join_t4 using (a) left join table_join_t1 as table_join_t5 using (a) left join table_join_t1 as table_join_t6 using (a) left join table_join_t1 as table_join_t7 using (a) left join table_join_t1 as table_join_t8 using (a) left join table_join_t1 as table_join_t9 using (a) left join table_join_t1 as table_join_t10 using (a) left join table_join_t1 as table_join_t11 using (a) left join table_join_t1 as table_join_t12 using (a) left join table_join_t1 as table_join_t13 using (a) left join table_join_t1 as table_join_t14 using (a) left join table_join_t1 as table_join_t15 using (a) left join table_join_t1 as table_join_t16 using (a) left join table_join_t1 as table_join_t17 using (a) left join table_join_t1 as table_join_t18 using (a) left join table_join_t1 as table_join_t19 using (a) left join table_join_t1 as table_join_t20 using (a) left join table_join_t1 as table_join_t21 using (a) left join table_join_t1 as table_join_t22 using (a) left join table_join_t1 as table_join_t23 using (a) left join table_join_t1 as table_join_t24 using (a) left join table_join_t1 as table_join_t25 using (a) left join table_join_t1 as table_join_t26 using (a) left join table_join_t1 as table_join_t27 using (a) left join table_join_t1 as table_join_t28 using (a) left join table_join_t1 as table_join_t29 using (a) left join table_join_t1 as table_join_t30 using (a) left join table_join_t1 as table_join_t31 using (a);
--replace_result "31 tables" "XX tables" "61 tables" "XX tables"
--error 1116
select table_join_t1.a from table_join_t1 as table_join_t1 left join table_join_t1 as table_join_t2 using (a) left join table_join_t1 as table_join_t3 using (a) left join table_join_t1 as table_join_t4 using (a) left join table_join_t1 as table_join_t5 using (a) left join table_join_t1 as table_join_t6 using (a) left join table_join_t1 as table_join_t7 using (a) left join table_join_t1 as table_join_t8 using (a) left join table_join_t1 as table_join_t9 using (a) left join table_join_t1 as table_join_t10 using (a) left join table_join_t1 as table_join_t11 using (a) left join table_join_t1 as table_join_t12 using (a) left join table_join_t1 as table_join_t13 using (a) left join table_join_t1 as table_join_t14 using (a) left join table_join_t1 as table_join_t15 using (a) left join table_join_t1 as table_join_t16 using (a) left join table_join_t1 as table_join_t17 using (a) left join table_join_t1 as table_join_t18 using (a) left join table_join_t1 as table_join_t19 using (a) left join table_join_t1 as table_join_t20 using (a) left join table_join_t1 as table_join_t21 using (a) left join table_join_t1 as table_join_t22 using (a) left join table_join_t1 as table_join_t23 using (a) left join table_join_t1 as table_join_t24 using (a) left join table_join_t1 as table_join_t25 using (a) left join table_join_t1 as table_join_t26 using (a) left join table_join_t1 as table_join_t27 using (a) left join table_join_t1 as table_join_t28 using (a) left join table_join_t1 as table_join_t29 using (a) left join table_join_t1 as table_join_t30 using (a) left join table_join_t1 as table_join_t31 using (a) left join table_join_t1 as table_join_t32 using (a) left join table_join_t1 as table_join_t33 using (a) left join table_join_t1 as table_join_t34 using (a) left join table_join_t1 as table_join_t35 using (a) left join table_join_t1 as table_join_t36 using (a) left join table_join_t1 as table_join_t37 using (a) left join table_join_t1 as table_join_t38 using (a) left join table_join_t1 as table_join_t39 using (a) left join table_join_t1 as table_join_t40 using (a) left join table_join_t1 as table_join_t41 using (a) left join table_join_t1 as table_join_t42 using (a) left join table_join_t1 as table_join_t43 using (a) left join table_join_t1 as table_join_t44 using (a) left join table_join_t1 as table_join_t45 using (a) left join table_join_t1 as table_join_t46 using (a) left join table_join_t1 as table_join_t47 using (a) left join table_join_t1 as table_join_t48 using (a) left join table_join_t1 as table_join_t49 using (a) left join table_join_t1 as table_join_t50 using (a) left join table_join_t1 as table_join_t51 using (a) left join table_join_t1 as table_join_t52 using (a) left join table_join_t1 as table_join_t53 using (a) left join table_join_t1 as table_join_t54 using (a) left join table_join_t1 as table_join_t55 using (a) left join table_join_t1 as table_join_t56 using (a) left join table_join_t1 as table_join_t57 using (a) left join table_join_t1 as table_join_t58 using (a) left join table_join_t1 as table_join_t59 using (a) left join table_join_t1 as table_join_t60 using (a) left join table_join_t1 as table_join_t61 using (a) left join table_join_t1 as table_join_t62 using (a) left join table_join_t1 as table_join_t63 using (a) left join table_join_t1 as table_join_t64 using (a) left join table_join_t1 as table_join_t65 using (a);
select a from table_join_t1 as table_join_t1 left join table_join_t1 as table_join_t2 using (a) left join table_join_t1 as table_join_t3 using (a) left join table_join_t1 as table_join_t4 using (a) left join table_join_t1 as table_join_t5 using (a) left join table_join_t1 as table_join_t6 using (a) left join table_join_t1 as table_join_t7 using (a) left join table_join_t1 as table_join_t8 using (a) left join table_join_t1 as table_join_t9 using (a) left join table_join_t1 as table_join_t10 using (a) left join table_join_t1 as table_join_t11 using (a) left join table_join_t1 as table_join_t12 using (a) left join table_join_t1 as table_join_t13 using (a) left join table_join_t1 as table_join_t14 using (a) left join table_join_t1 as table_join_t15 using (a) left join table_join_t1 as table_join_t16 using (a) left join table_join_t1 as table_join_t17 using (a) left join table_join_t1 as table_join_t18 using (a) left join table_join_t1 as table_join_t19 using (a) left join table_join_t1 as table_join_t20 using (a) left join table_join_t1 as table_join_t21 using (a) left join table_join_t1 as table_join_t22 using (a) left join table_join_t1 as table_join_t23 using (a) left join table_join_t1 as table_join_t24 using (a) left join table_join_t1 as table_join_t25 using (a) left join table_join_t1 as table_join_t26 using (a) left join table_join_t1 as table_join_t27 using (a) left join table_join_t1 as table_join_t28 using (a) left join table_join_t1 as table_join_t29 using (a) left join table_join_t1 as table_join_t30 using (a) left join table_join_t1 as table_join_t31 using (a);
--replace_result "31 tables" "XX tables" "61 tables" "XX tables"
--error 1116
select a from table_join_t1 as table_join_t1 left join table_join_t1 as table_join_t2 using (a) left join table_join_t1 as table_join_t3 using (a) left join table_join_t1 as table_join_t4 using (a) left join table_join_t1 as table_join_t5 using (a) left join table_join_t1 as table_join_t6 using (a) left join table_join_t1 as table_join_t7 using (a) left join table_join_t1 as table_join_t8 using (a) left join table_join_t1 as table_join_t9 using (a) left join table_join_t1 as table_join_t10 using (a) left join table_join_t1 as table_join_t11 using (a) left join table_join_t1 as table_join_t12 using (a) left join table_join_t1 as table_join_t13 using (a) left join table_join_t1 as table_join_t14 using (a) left join table_join_t1 as table_join_t15 using (a) left join table_join_t1 as table_join_t16 using (a) left join table_join_t1 as table_join_t17 using (a) left join table_join_t1 as table_join_t18 using (a) left join table_join_t1 as table_join_t19 using (a) left join table_join_t1 as table_join_t20 using (a) left join table_join_t1 as table_join_t21 using (a) left join table_join_t1 as table_join_t22 using (a) left join table_join_t1 as table_join_t23 using (a) left join table_join_t1 as table_join_t24 using (a) left join table_join_t1 as table_join_t25 using (a) left join table_join_t1 as table_join_t26 using (a) left join table_join_t1 as table_join_t27 using (a) left join table_join_t1 as table_join_t28 using (a) left join table_join_t1 as table_join_t29 using (a) left join table_join_t1 as table_join_t30 using (a) left join table_join_t1 as table_join_t31 using (a) left join table_join_t1 as table_join_t32 using (a) left join table_join_t1 as table_join_t33 using (a) left join table_join_t1 as table_join_t34 using (a) left join table_join_t1 as table_join_t35 using (a) left join table_join_t1 as table_join_t36 using (a) left join table_join_t1 as table_join_t37 using (a) left join table_join_t1 as table_join_t38 using (a) left join table_join_t1 as table_join_t39 using (a) left join table_join_t1 as table_join_t40 using (a) left join table_join_t1 as table_join_t41 using (a) left join table_join_t1 as table_join_t42 using (a) left join table_join_t1 as table_join_t43 using (a) left join table_join_t1 as table_join_t44 using (a) left join table_join_t1 as table_join_t45 using (a) left join table_join_t1 as table_join_t46 using (a) left join table_join_t1 as table_join_t47 using (a) left join table_join_t1 as table_join_t48 using (a) left join table_join_t1 as table_join_t49 using (a) left join table_join_t1 as table_join_t50 using (a) left join table_join_t1 as table_join_t51 using (a) left join table_join_t1 as table_join_t52 using (a) left join table_join_t1 as table_join_t53 using (a) left join table_join_t1 as table_join_t54 using (a) left join table_join_t1 as table_join_t55 using (a) left join table_join_t1 as table_join_t56 using (a) left join table_join_t1 as table_join_t57 using (a) left join table_join_t1 as table_join_t58 using (a) left join table_join_t1 as table_join_t59 using (a) left join table_join_t1 as table_join_t60 using (a) left join table_join_t1 as table_join_t61 using (a) left join table_join_t1 as table_join_t62 using (a) left join table_join_t1 as table_join_t63 using (a) left join table_join_t1 as table_join_t64 using (a) left join table_join_t1 as table_join_t65 using (a);
drop table table_join_t1;

#
# Simple join test. This failed in 3.23.42, there should have been
# no matches, still three matches were found.
#
 
CREATE TABLE table_join_t1 (
  a int(11) NOT NULL,
  b int(11) NOT NULL,
  PRIMARY KEY  (a,b)
) ENGINE=SequoiaDB;
 
INSERT INTO table_join_t1 VALUES (1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(2,3);
 
CREATE TABLE table_join_t2 (
  a int(11) default NULL
) ENGINE=SequoiaDB;
INSERT INTO table_join_t2 VALUES (2),(3);
SELECT table_join_t1.a,table_join_t2.a,b FROM table_join_t1,table_join_t2 WHERE table_join_t1.a=table_join_t2.a AND (table_join_t1.a=1 OR table_join_t1.a=2) AND b>=1 AND b<=3;
DROP TABLE table_join_t1, table_join_t2;

#
# TEST LEFT JOIN with DATE columns
#

CREATE TABLE table_join_t1 (d DATE NOT NULL);
CREATE TABLE table_join_t2 (d DATE NOT NULL);
INSERT INTO table_join_t1 (d) VALUES ('2001-08-01'),('1000-01-01');
SELECT * FROM table_join_t1 LEFT JOIN table_join_t2 USING (d) WHERE table_join_t2.d IS NULL;
SELECT * FROM table_join_t1 LEFT JOIN table_join_t2 USING (d) WHERE d IS NULL;
SELECT * from table_join_t1 WHERE table_join_t1.d IS NULL;
SELECT * FROM table_join_t1 WHERE 1/0 IS NULL;
DROP TABLE table_join_t1,table_join_t2;

#
# Problem with reference from const tables
#
CREATE TABLE table_join_t1 (
  Document_ID varchar(50) NOT NULL default '',
  Contractor_ID varchar(6) NOT NULL default '',
  Language_ID char(3) NOT NULL default '',
  Expiration_Date datetime default NULL,
  Publishing_Date datetime default NULL,
  Title text,
  Column_ID varchar(50) NOT NULL default '',
  PRIMARY KEY  (Language_ID,Document_ID,Contractor_ID)
);

INSERT INTO table_join_t1 VALUES ('xep80','1','ger','2001-12-31 20:00:00','2001-11-12 10:58:00','Kartenbestellung - jetzt auch online','anle'),('','999998','',NULL,NULL,NULL,'');

CREATE TABLE table_join_t2 (
  Contractor_ID char(6) NOT NULL default '',
  Language_ID char(3) NOT NULL default '',
  Document_ID char(50) NOT NULL default '',
  CanRead char(1) default NULL,
  Customer_ID int(11) NOT NULL default '0',
  PRIMARY KEY  (Contractor_ID,Language_ID,Document_ID,Customer_ID)
);

INSERT INTO table_join_t2 VALUES ('5','ger','xep80','1',999999),('1','ger','xep80','1',999999);
CREATE TABLE table_join_t3 (
  Language_ID char(3) NOT NULL default '',
  Column_ID char(50) NOT NULL default '',
  Contractor_ID char(6) NOT NULL default '',
  CanRead char(1) default NULL,
  Active char(1) default NULL,
  PRIMARY KEY  (Language_ID,Column_ID,Contractor_ID)
);
INSERT INTO table_join_t3 VALUES ('ger','home','1','1','1'),('ger','Test','1','0','0'),('ger','derclu','1','0','0'),('ger','clubne','1','0','0'),('ger','philos','1','0','0'),('ger','clubko','1','0','0'),('ger','clubim','1','1','1'),('ger','progra','1','0','0'),('ger','progvo','1','0','0'),('ger','progsp','1','0','0'),('ger','progau','1','0','0'),('ger','progku','1','0','0'),('ger','progss','1','0','0'),('ger','nachl','1','0','0'),('ger','mitgli','1','0','0'),('ger','mitsu','1','0','0'),('ger','mitbus','1','0','0'),('ger','ergmar','1','1','1'),('ger','home','4','1','1'),('ger','derclu','4','1','1'),('ger','clubne','4','0','0'),('ger','philos','4','1','1'),('ger','clubko','4','1','1'),('ger','clubim','4','1','1'),('ger','progra','4','1','1'),('ger','progvo','4','1','1'),('ger','progsp','4','1','1'),('ger','progau','4','0','0'),('ger','progku','4','1','1'),('ger','progss','4','1','1'),('ger','nachl','4','1','1'),('ger','mitgli','4','0','0'),('ger','mitsu','4','0','0'),('ger','mitbus','4','0','0'),('ger','ergmar','4','1','1'),('ger','progra2','1','0','0'),('ger','archiv','4','1','1'),('ger','anmeld','4','1','1'),('ger','thema','4','1','1'),('ger','edito','4','1','1'),('ger','madis','4','1','1'),('ger','enma','4','1','1'),('ger','madis','1','1','1'),('ger','enma','1','1','1'),('ger','vorsch','4','0','0'),('ger','veranst','4','0','0'),('ger','anle','4','1','1'),('ger','redak','4','1','1'),('ger','nele','4','1','1'),('ger','aukt','4','1','1'),('ger','callcenter','4','1','1'),('ger','anle','1','0','0');
delete from table_join_t1 where Contractor_ID='999998';
insert into table_join_t1 (Contractor_ID) Values ('999998');
SELECT DISTINCT COUNT(table_join_t1.Title) FROM table_join_t1,
table_join_t2, table_join_t3 WHERE 
table_join_t1.Document_ID='xep80' AND table_join_t1.Contractor_ID='1' AND 
table_join_t1.Language_ID='ger' AND '2001-12-21 23:14:24' >= 
Publishing_Date AND '2001-12-21 23:14:24' <= Expiration_Date AND 
table_join_t1.Document_ID = table_join_t2.Document_ID AND 
table_join_t1.Language_ID = table_join_t2.Language_ID AND 
table_join_t1.Contractor_ID = table_join_t2.Contractor_ID AND ( 
table_join_t2.Customer_ID = '4'  OR 
table_join_t2.Customer_ID = '999999'  OR 
table_join_t2.Customer_ID = '1' )AND table_join_t2.CanRead 
= '1'  AND table_join_t1.Column_ID=table_join_t3.Column_ID AND 
table_join_t1.Language_ID=table_join_t3.Language_ID AND ( 
table_join_t3.Contractor_ID = '4'  OR 
table_join_t3.Contractor_ID = '999999'  OR 
table_join_t3.Contractor_ID = '1') AND 
table_join_t3.CanRead='1' AND table_join_t3.Active='1';
SELECT DISTINCT COUNT(table_join_t1.Title) FROM table_join_t1,
table_join_t2, table_join_t3 WHERE 
table_join_t1.Document_ID='xep80' AND table_join_t1.Contractor_ID='1' AND 
table_join_t1.Language_ID='ger' AND '2001-12-21 23:14:24' >= 
Publishing_Date AND '2001-12-21 23:14:24' <= Expiration_Date AND 
table_join_t1.Document_ID = table_join_t2.Document_ID AND 
table_join_t1.Language_ID = table_join_t2.Language_ID AND 
table_join_t1.Contractor_ID = table_join_t2.Contractor_ID AND ( 
table_join_t2.Customer_ID = '4'  OR 
table_join_t2.Customer_ID = '999999'  OR 
table_join_t2.Customer_ID = '1' )AND table_join_t2.CanRead 
= '1'  AND table_join_t1.Column_ID=table_join_t3.Column_ID AND 
table_join_t1.Language_ID=table_join_t3.Language_ID AND ( 
table_join_t3.Contractor_ID = '4'  OR 
table_join_t3.Contractor_ID = '999999'  OR 
table_join_t3.Contractor_ID = '1') AND 
table_join_t3.CanRead='1' AND table_join_t3.Active='1';
drop table table_join_t1,table_join_t2,table_join_t3;

#
# Bug when doing full join and NULL fields.
#

CREATE TABLE table_join_t1 (
  table_join_t1_id int(11) default NULL,
  table_join_t2_id int(11) default NULL,
  type enum('Cost','Percent') default NULL,
  cost_unit enum('Cost','Unit') default NULL,
  min_value double default NULL,
  max_value double default NULL,
  table_join_t3_id int(11) default NULL,
  item_id int(11) default NULL
) ENGINE=SequoiaDB;
INSERT INTO table_join_t1 VALUES (12,5,'Percent','Cost',-1,0,-1,-1),(14,4,'Percent','Cost',-1,0,-1,-1),(18,5,'Percent','Cost',-1,0,-1,-1),(19,4,'Percent','Cost',-1,0,-1,-1),(20,5,'Percent','Cost',100,-1,22,291),(21,5,'Percent','Cost',100,-1,18,291),(22,1,'Percent','Cost',100,-1,6,291),(23,1,'Percent','Cost',100,-1,21,291),(24,1,'Percent','Cost',100,-1,9,291),(25,1,'Percent','Cost',100,-1,4,291),(26,1,'Percent','Cost',100,-1,20,291),(27,4,'Percent','Cost',100,-1,7,202),(28,1,'Percent','Cost',50,-1,-1,137),(29,2,'Percent','Cost',100,-1,4,354),(30,2,'Percent','Cost',100,-1,9,137),(93,2,'Cost','Cost',-1,10000000,-1,-1);
CREATE TABLE table_join_t2 (
  id int(10) unsigned NOT NULL,
  name varchar(255) default NULL,
  PRIMARY KEY  (id)
) ENGINE=SequoiaDB;
INSERT INTO table_join_t2 VALUES (1,'s1'),(2,'s2'),(3,'s3'),(4,'s4'),(5,'s5');
select table_join_t1.*, table_join_t2.*  from table_join_t1, table_join_t2 where table_join_t2.id=table_join_t1.table_join_t2_id limit 2;
drop table table_join_t1,table_join_t2;

#
# Bug in range optimiser with MAYBE_KEY
#

CREATE TABLE table_join_t1 (
  siteid varchar(25) NOT NULL default '',
  emp_id varchar(30) NOT NULL default '',
  rate_code varchar(10) default NULL,
  UNIQUE KEY site_emp (siteid,emp_id),
  KEY siteid (siteid)
) ENGINE=SequoiaDB;
INSERT INTO table_join_t1 VALUES ('rivercats','psmith','cust'), ('rivercats','KWalker','cust');
CREATE TABLE table_join_t2 (
  siteid varchar(25) NOT NULL default '',
  rate_code varchar(10) NOT NULL default '',
  base_rate float NOT NULL default '0',
  PRIMARY KEY  (siteid,rate_code)
) ENGINE=SequoiaDB;
INSERT INTO table_join_t2 VALUES ('rivercats','cust',20);
SELECT emp.rate_code, lr.base_rate FROM table_join_t1 AS emp LEFT JOIN table_join_t2 AS lr USING (siteid, rate_code) WHERE emp.emp_id = 'psmith' AND lr.siteid = 'rivercats';
SELECT emp.rate_code, lr.base_rate FROM table_join_t1 AS emp LEFT JOIN table_join_t2 AS lr USING (siteid, rate_code) WHERE lr.siteid = 'rivercats' AND emp.emp_id = 'psmith';
SELECT rate_code, lr.base_rate FROM table_join_t1 AS emp LEFT JOIN table_join_t2 AS lr USING (siteid, rate_code) WHERE emp.emp_id = 'psmith' AND siteid = 'rivercats';
SELECT rate_code, lr.base_rate FROM table_join_t1 AS emp LEFT JOIN table_join_t2 AS lr USING (siteid, rate_code) WHERE siteid = 'rivercats' AND emp.emp_id = 'psmith';
drop table table_join_t1,table_join_t2;

#
# Problem with internal list handling when reducing WHERE
#

CREATE TABLE table_join_t1 (ID INTEGER NOT NULL PRIMARY KEY, Value1 VARCHAR(255));
CREATE TABLE table_join_t2 (ID INTEGER NOT NULL PRIMARY KEY, Value2 VARCHAR(255));
INSERT INTO table_join_t1 VALUES (1, 'A');
INSERT INTO table_join_t2 VALUES (1, 'B');

SELECT * FROM table_join_t1 NATURAL JOIN table_join_t2 WHERE 1 AND (Value1 = 'A' AND Value2 <> 'B');
SELECT * FROM table_join_t1 NATURAL JOIN table_join_t2 WHERE 1 AND Value1 = 'A' AND Value2 <> 'B';
SELECT * FROM table_join_t1 NATURAL JOIN table_join_t2 WHERE (Value1 = 'A' AND Value2 <> 'B') AND 1;
drop table table_join_t1,table_join_t2;

#
# dummy natural join (no common columns) Bug #4807
#

CREATE TABLE table_join_t1 (a int);
CREATE TABLE table_join_t2 (b int);
CREATE TABLE table_join_t3 (c int);
SELECT * FROM table_join_t1 NATURAL JOIN table_join_t2 NATURAL JOIN table_join_t3;
DROP TABLE table_join_t1, table_join_t2, table_join_t3;

#
# Test combination of join methods
#

create table table_join_t1 (i int);
create table table_join_t2 (i int);
create table table_join_t3 (i int);
insert into table_join_t1 values(1),(2);
insert into table_join_t2 values(2),(3);
insert into table_join_t3 values (2),(4);

--sorted_result
select * from table_join_t1 natural left join table_join_t2;
--sorted_result
select * from table_join_t1 left join table_join_t2 on (table_join_t1.i=table_join_t2.i);
--sorted_result
select * from table_join_t1 natural left join table_join_t2 natural left join table_join_t3;
--sorted_result
select * from table_join_t1 left join table_join_t2 on (table_join_t1.i=table_join_t2.i) left join table_join_t3 on (table_join_t2.i=table_join_t3.i);

select * from table_join_t3 natural right join table_join_t2;
select * from table_join_t3 right join table_join_t2 on (table_join_t3.i=table_join_t2.i);
--sorted_result
select * from table_join_t3 natural right join table_join_t2 natural right join table_join_t1;
--sorted_result
select * from table_join_t3 right join table_join_t2 on (table_join_t3.i=table_join_t2.i) right join table_join_t1 on (table_join_t2.i=table_join_t1.i);

select * from table_join_t1,table_join_t2 natural left join table_join_t3 order by table_join_t1.i,table_join_t2.i,table_join_t3.i;
select * from table_join_t1,table_join_t2 left join table_join_t3 on (table_join_t2.i=table_join_t3.i) order by table_join_t1.i,table_join_t2.i,table_join_t3.i;
select table_join_t1.i,table_join_t2.i,table_join_t3.i from table_join_t2 natural left join table_join_t3,table_join_t1 order by table_join_t1.i,table_join_t2.i,table_join_t3.i;
select table_join_t1.i,table_join_t2.i,table_join_t3.i from table_join_t2 left join table_join_t3 on (table_join_t2.i=table_join_t3.i),table_join_t1 order by table_join_t1.i,table_join_t2.i,table_join_t3.i;

select * from table_join_t1,table_join_t2 natural right join table_join_t3 order by table_join_t1.i,table_join_t2.i,table_join_t3.i;
select * from table_join_t1,table_join_t2 right join table_join_t3 on (table_join_t2.i=table_join_t3.i) order by table_join_t1.i,table_join_t2.i,table_join_t3.i;
select table_join_t1.i,table_join_t2.i,table_join_t3.i from table_join_t2 natural right join table_join_t3,table_join_t1 order by table_join_t1.i,table_join_t2.i,table_join_t3.i;
select table_join_t1.i,table_join_t2.i,table_join_t3.i from table_join_t2 right join table_join_t3 on (table_join_t2.i=table_join_t3.i),table_join_t1 order by table_join_t1.i,table_join_t2.i,table_join_t3.i;
drop table table_join_t1,table_join_t2,table_join_t3;

#
# Bug #27531: Query performance degredation in 4.1.22 and greater
#
CREATE TABLE table_join_t1 (a int, b int default 0, c int default 1);

INSERT INTO table_join_t1 (a) VALUES (1),(2),(3),(4),(5),(6),(7),(8);
INSERT INTO table_join_t1 (a) SELECT a + 8 FROM table_join_t1;
INSERT INTO table_join_t1 (a) SELECT a + 16 FROM table_join_t1;

CREATE TABLE table_join_t2 (a int, d int, e int default 0);

INSERT INTO table_join_t2 (a, d) VALUES (1,1),(2,2),(3,3),(4,4);
INSERT INTO table_join_t2 (a, d) SELECT a+4, a+4 FROM table_join_t2;
INSERT INTO table_join_t2 (a, d) SELECT a+8, a+8 FROM table_join_t2;

# should use join cache
EXPLAIN
SELECT STRAIGHT_JOIN table_join_t2.e FROM table_join_t1,table_join_t2 WHERE table_join_t2.d=1 AND table_join_t1.b=table_join_t2.e
  ORDER BY table_join_t1.b, table_join_t1.c;
SELECT STRAIGHT_JOIN table_join_t2.e FROM table_join_t1,table_join_t2 WHERE table_join_t2.d=1 AND table_join_t1.b=table_join_t2.e
  ORDER BY table_join_t1.b, table_join_t1.c;

DROP TABLE table_join_t1,table_join_t2;

# End of 4.1 tests

#
#  Tests for WL#2486 Natural/using join according to SQL:2003.
#
#  NOTICE:
#  - The tests are designed so that all statements, except MySQL
#    extensions run on any SQL server. Please do no change.
#  - Tests marked with TODO will be submitted as bugs.
#

create table table_join_t1 (c int, b int);
create table table_join_t2 (a int, b int);
create table table_join_t3 (b int, c int);
create table table_join_t4 (y int, c int);
create table table_join_t5 (y int, z int);
create table table_join_t6 (a int, c int);

insert into table_join_t1 values (10,1);
insert into table_join_t1 values (3 ,1);
insert into table_join_t1 values (3 ,2);
insert into table_join_t2 values (2, 1);
insert into table_join_t3 values (1, 3);
insert into table_join_t3 values (1,10);
insert into table_join_t4 values (11,3);
insert into table_join_t4 values (2, 3);
insert into table_join_t5 values (11,4);
insert into table_join_t6 values (2, 3);

# Views with simple natural join.
create algorithm=merge view v1a as
select * from table_join_t1 natural join table_join_t2;
# as above, but column names are cross-renamed: a->c, c->b, b->a
create algorithm=merge view v1b(a,b,c) as
select * from table_join_t1 natural join table_join_t2;
# as above, but column names are aliased: a->c, c->b, b->a
create algorithm=merge view v1c as
select b as a, c as b, a as c from table_join_t1 natural join table_join_t2;
#  as above, but column names are cross-renamed, and aliased
#  a->c->b, c->b->a, b->a->c
create algorithm=merge view v1d(b, a, c) as
select a as c, c as b, b as a from table_join_t1 natural join table_join_t2;

# Views with JOIN ... ON
create algorithm=merge view v2a as
select table_join_t1.c, table_join_t1.b, table_join_t2.a from table_join_t1 join (table_join_t2 join table_join_t4 on b + 1 = y) on table_join_t1.c = table_join_t4.c;
create algorithm=merge view v2b as
select table_join_t1.c as b, table_join_t1.b as a, table_join_t2.a as c
from table_join_t1 join (table_join_t2 join table_join_t4 on b + 1 = y) on table_join_t1.c = table_join_t4.c;

# Views with bigger natural join
create algorithm=merge view v3a as
select * from table_join_t1 natural join table_join_t2 natural join table_join_t3;
create algorithm=merge view v3b as
select * from table_join_t1 natural join (table_join_t2 natural join table_join_t3);

# View over views with mixed natural join and join ... on
create algorithm=merge view v4 as
select * from v2a natural join v3a;

# Nested natural/using joins.
select * from (table_join_t1 natural join table_join_t2) natural join (table_join_t3 natural join table_join_t4);
--sorted_result
select * from (table_join_t1 natural join table_join_t2) natural left join (table_join_t3 natural join table_join_t4);
--sorted_result
select * from (table_join_t3 natural join table_join_t4) natural right join (table_join_t1 natural join table_join_t2);
--sorted_result
select * from (table_join_t1 natural left join table_join_t2) natural left join (table_join_t3 natural left join table_join_t4);
--sorted_result
select * from (table_join_t4 natural right join table_join_t3) natural right join (table_join_t2 natural right join table_join_t1);
select * from table_join_t1 natural join table_join_t2 natural join table_join_t3 natural join table_join_t4;
select * from ((table_join_t1 natural join table_join_t2) natural join table_join_t3) natural join table_join_t4;
select * from table_join_t1 natural join (table_join_t2 natural join (table_join_t3 natural join table_join_t4));
# BUG#15355: this query fails in 'prepared statements' mode
# select * from ((table_join_t3 natural join (table_join_t1 natural join table_join_t2)) natural join table_join_t4) natural join table_join_t5;
# select * from ((table_join_t3 natural left join (table_join_t1 natural left join table_join_t2)) natural left join table_join_t4) natural left join table_join_t5;
select * from table_join_t5 natural right join (table_join_t4 natural right join ((table_join_t2 natural right join table_join_t1) natural right join table_join_t3));
select * from (table_join_t1 natural join table_join_t2), (table_join_t3 natural join table_join_t4);
# MySQL extension - nested comma ',' operator instead of cross join.
select * from table_join_t5 natural join ((table_join_t1 natural join table_join_t2), (table_join_t3 natural join table_join_t4));
select * from  ((table_join_t1 natural join table_join_t2),  (table_join_t3 natural join table_join_t4)) natural join table_join_t5;
select * from table_join_t5 natural join ((table_join_t1 natural join table_join_t2) cross join (table_join_t3 natural join table_join_t4));
select * from  ((table_join_t1 natural join table_join_t2) cross join (table_join_t3 natural join table_join_t4)) natural join table_join_t5;

select * from (table_join_t1 join table_join_t2 using (b)) join (table_join_t3 join table_join_t4 using (c)) using (c);
select * from (table_join_t1 join table_join_t2 using (b)) natural join (table_join_t3 join table_join_t4 using (c));


# Other clauses refer to NJ columns.
select a,b,c from (table_join_t1 natural join table_join_t2) natural join (table_join_t3 natural join table_join_t4)
where b + 1 = y or b + 10 = y group by b,c,a having min(b) < max(y) order by a;
select * from (table_join_t1 natural join table_join_t2) natural left join (table_join_t3 natural join table_join_t4)
where b + 1 = y or b + 10 = y group by b,c,a,y having min(b) < max(y) order by a, y;
select * from (table_join_t3 natural join table_join_t4) natural right join (table_join_t1 natural join table_join_t2)
where b + 1 = y or b + 10 = y group by b,c,a,y having min(b) < max(y) order by a, y;

# Qualified column references to NJ columns.
select * from table_join_t1 natural join table_join_t2 where table_join_t1.c > table_join_t2.a;
select * from table_join_t1 natural join table_join_t2 where table_join_t1.b > table_join_t2.b;
select * from table_join_t1 natural left join (table_join_t4 natural join table_join_t5) where table_join_t5.z is not NULL;

# Nested 'join ... on' - name resolution of ON conditions
select * from table_join_t1 join (table_join_t2 join table_join_t4 on b + 1 = y) on table_join_t1.c = table_join_t4.c;
select * from (table_join_t2 join table_join_t4 on b + 1 = y) join table_join_t1 on table_join_t1.c = table_join_t4.c;
select * from table_join_t1 natural join (table_join_t2 join table_join_t4 on b + 1 = y);
select * from (table_join_t1 cross join table_join_t2) join (table_join_t3 cross join table_join_t4) on (a < y and table_join_t2.b < table_join_t3.c);

# MySQL extension - 'join ... on' over nested comma operator
select * from (table_join_t1, table_join_t2) join (table_join_t3, table_join_t4) on (a < y and table_join_t2.b < table_join_t3.c);
select * from (table_join_t1 natural join table_join_t2) join (table_join_t3 natural join table_join_t4) on a = y;
select * from ((table_join_t3 join (table_join_t1 join table_join_t2 on c > a) on table_join_t3.b < table_join_t2.a) join table_join_t4 on y > table_join_t1.c) join table_join_t5 on z = table_join_t1.b + 3;

# MySQL extension - refererence qualified coalesced columns
select * from table_join_t1 natural join table_join_t2 where table_join_t1.b > 0;
select * from table_join_t1 natural join (table_join_t4 natural join table_join_t5) where table_join_t4.y > 7;
select * from (table_join_t4 natural join table_join_t5) natural join table_join_t1 where table_join_t4.y > 7;
select * from table_join_t1 natural left join (table_join_t4 natural join table_join_t5) where table_join_t4.y > 7;
select * from (table_join_t4 natural join table_join_t5) natural right join table_join_t1 where table_join_t4.y > 7;
select * from (table_join_t1 natural join table_join_t2) join (table_join_t3 natural join table_join_t4) on table_join_t1.b = table_join_t3.b;

# MySQL extension - select qualified columns of NJ columns
select table_join_t1.*, table_join_t2.* from table_join_t1 natural join table_join_t2;
select table_join_t1.*, table_join_t2.*, table_join_t3.*, table_join_t4.* from (table_join_t1 natural join table_join_t2) natural join (table_join_t3 natural join table_join_t4);

# Queries over subselects in the FROM clause
--sorted_result
select * from (select * from table_join_t1 natural join table_join_t2) as table_join_t12
              natural join
              (select * from table_join_t3 natural join table_join_t4) as table_join_t34;
--sorted_result
select * from (select * from table_join_t1 natural join table_join_t2) as table_join_t12
              natural left join
              (select * from table_join_t3 natural join table_join_t4) as table_join_t34;
--sorted_result
select * from (select * from table_join_t3 natural join table_join_t4) as table_join_t34
              natural right join
              (select * from table_join_t1 natural join table_join_t2) as table_join_t12;

# Queries over views
select * from v1a;
select * from v1b;
select * from v1c;
select * from v1d;
select * from v2a;
select * from v2b;
select * from v3a;
select * from v3b;
select * from v4;
select * from v1a natural join v2a;
select v2a.* from v1a natural join v2a;
select * from v1b join v2a on v1b.b = v2a.c;
select * from v1c join v2a on v1c.b = v2a.c;
select * from v1d join v2a on v1d.a = v2a.c;
select * from v1a join (table_join_t3 natural join table_join_t4) on a = y;

# TODO: add tests with correlated subqueries for natural join/join on.
# related to BUG#15269


#--------------------------------------------------------------------
# Negative tests (tests for errors)
#--------------------------------------------------------------------
# works in Oracle - bug
-- error 1052
select * from table_join_t1 natural join (table_join_t3 cross join table_join_t4);
# works in Oracle - bug
-- error 1052
select * from (table_join_t3 cross join table_join_t4) natural join table_join_t1;
-- error 1052
select * from table_join_t1 join (table_join_t2, table_join_t3) using (b);
-- error 1052
select * from ((table_join_t1 natural join table_join_t2), (table_join_t3 natural join table_join_t4)) natural join table_join_t6;
-- error 1052
select * from ((table_join_t1 natural join table_join_t2), (table_join_t3 natural join table_join_t4)) natural join table_join_t6;
-- error 1052
select * from table_join_t6 natural join ((table_join_t1 natural join table_join_t2),  (table_join_t3 natural join table_join_t4));
-- error 1052
select * from (table_join_t1 join table_join_t2 on table_join_t1.b=table_join_t2.b) natural join (table_join_t3 natural join table_join_t4);
-- error 1052
select * from  (table_join_t3 natural join table_join_t4) natural join (table_join_t1 join table_join_t2 on table_join_t1.b=table_join_t2.b);
# this one is OK, the next equivalent one is incorrect (bug in Oracle)
-- error 1052
select * from (table_join_t3 join (table_join_t4 natural join table_join_t5) on (b < z))
              natural join
              (table_join_t1 natural join table_join_t2);
-- error 1052
select * from (table_join_t1 natural join table_join_t2) natural join (table_join_t3 join (table_join_t4 natural join table_join_t5) on (b < z));

-- error 1054
select table_join_t1.b from v1a;
-- error 1054
select * from v1a join v1b on table_join_t1.b = table_join_t2.b;

#
# Bug #17523 natural join and information_schema
#
# Omit columns.PRIVILIGES as it may vary with embedded server.
# Omit columns.ORDINAL_POSITION and statistics.CARDINALITY as it may vary with hostname='localhost'.
select 
 statistics.TABLE_NAME, statistics.COLUMN_NAME, statistics.TABLE_CATALOG, statistics.TABLE_SCHEMA, statistics.NON_UNIQUE, statistics.INDEX_SCHEMA, statistics.INDEX_NAME, statistics.SEQ_IN_INDEX, statistics.COLLATION, statistics.SUB_PART, statistics.PACKED, statistics.NULLABLE, statistics.INDEX_TYPE, statistics.COMMENT, 
 columns.TABLE_CATALOG, columns.TABLE_SCHEMA, columns.COLUMN_DEFAULT, columns.IS_NULLABLE, columns.DATA_TYPE, columns.CHARACTER_MAXIMUM_LENGTH, columns.CHARACTER_OCTET_LENGTH, columns.NUMERIC_PRECISION, columns.NUMERIC_SCALE, columns.CHARACTER_SET_NAME, columns.COLLATION_NAME, columns.COLUMN_TYPE, columns.COLUMN_KEY, columns.EXTRA, columns.COLUMN_COMMENT
 from information_schema.statistics join information_schema.columns using(table_name,column_name) where table_name='user';

drop table table_join_t1;
drop table table_join_t2;
drop table table_join_t3;
drop table table_join_t4;
drop table table_join_t5;
drop table table_join_t6;

drop view v1a;
drop view v1b;
drop view v1c;
drop view v1d;
drop view v2a;
drop view v2b;
drop view v3a;
drop view v3b;
drop view v4;

#
# BUG#15229 - columns of nested joins that are not natural joins incorrectly
# materialized
#
create table table_join_t1 (a1 int, a2 int);
create table table_join_t2 (a1 int, b int);
create table table_join_t3 (c1 int, c2 int);
create table table_join_t4 (c2 int);

insert into table_join_t1 values (1,1);
insert into table_join_t2 values (1,1);
insert into table_join_t3 values (1,1);
insert into table_join_t4 values (1);

select * from table_join_t1 join table_join_t2 using (a1) join table_join_t3 on b=c1 join table_join_t4 using (c2);
select * from table_join_t3 join (table_join_t1 join table_join_t2 using (a1)) on b=c1 join table_join_t4 using (c2);
select a2 from table_join_t1 join table_join_t2 using (a1) join table_join_t3 on b=c1 join table_join_t4 using (c2);
select a2 from table_join_t3 join (table_join_t1 join table_join_t2 using (a1)) on b=c1 join table_join_t4 using (c2);
select a2 from ((table_join_t1 join table_join_t2 using (a1)) join table_join_t3 on b=c1) join table_join_t4 using (c2);
select a2 from ((table_join_t1 natural join table_join_t2) join table_join_t3 on b=c1) natural join table_join_t4;

drop table table_join_t1,table_join_t2,table_join_t3,table_join_t4;

#
# BUG#15355: Common natural join column not resolved in prepared statement nested query
#
create table table_join_t1 (c int, b int);
create table table_join_t2 (a int, b int);
create table table_join_t3 (b int, c int);
create table table_join_t4 (y int, c int);
create table table_join_t5 (y int, z int);

insert into table_join_t1 values (3,2);
insert into table_join_t2 values (1,2);
insert into table_join_t3 values (2,3);
insert into table_join_t4 values (1,3);
insert into table_join_t5 values (1,4);

# this fails
prepare stmtable_join_t1 from "select * from ((table_join_t3 natural join (table_join_t1 natural join table_join_t2))
natural join table_join_t4) natural join table_join_t5";
execute stmtable_join_t1;

# this works
select * from ((table_join_t3 natural join (table_join_t1 natural join table_join_t2)) natural join table_join_t4)
  natural join table_join_t5;
drop table table_join_t1, table_join_t2, table_join_t3, table_join_t4, table_join_t5;

# End of tests for WL#2486 - natural/using join

#
# BUG#25106: A USING clause in combination with a VIEW results in column 
#            aliases ignored
#
CREATE TABLE table_join_t1 (ID INTEGER, Name VARCHAR(50));
CREATE TABLE table_join_t2 (Test_ID INTEGER);
CREATE VIEW v1 (Test_ID, Description) AS SELECT ID, Name FROM table_join_t1;

CREATE TABLE tv1 SELECT Description AS Name FROM v1 JOIN table_join_t2
 USING (Test_ID);
DESCRIBE tv1;
CREATE TABLE tv2 SELECT Description AS Name FROM v1 JOIN table_join_t2
 ON v1.Test_ID = table_join_t2.Test_ID;
DESCRIBE tv2;

DROP VIEW v1;
DROP TABLE table_join_t1,table_join_t2,tv1,tv2;


# BUG#27939: Early NULLs filtering doesn't work for eq_ref access
create table table_join_t1 (a int, b int);
insert into table_join_t1 values 
  (NULL, 1),
  (NULL, 2),
  (NULL, 3),
  (NULL, 4);

create table table_join_t2 (a int not null, primary key(a));
insert into table_join_t2 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);

create table table_join_t3 (a int not null, primary key(a));
insert into table_join_t3 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);

flush status;
select * from table_join_t1, table_join_t2, table_join_t3 where table_join_t3.a=table_join_t1.a and table_join_t2.a=table_join_t1.b;
explain select * from table_join_t1, table_join_t2, table_join_t3 where table_join_t3.a=table_join_t1.a and table_join_t2.a=table_join_t1.b;
--echo We expect rnd_next=5, and read_key must be 0 because of short-cutting:
show status like 'Handler_read%'; 
drop table table_join_t1, table_join_t2, table_join_t3;

#
# BUG#14940: Make E(#rows) from "range" access be re-used by range optimizer
#
create table table_join_t1 (a int); 
insert into table_join_t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);

create table table_join_t2 (a int, b int, filler char(100), key(a), key(b));
create table table_join_t3 (a int, b int, filler char(100), key(a), key(b));

insert into table_join_t2 
  select @a:= A.a + 10*(B.a + 10*C.a), @a, 'filler' from table_join_t1 A, table_join_t1 B, table_join_t1 C;
insert into table_join_t3 select * from table_join_t2 where a < 800;

# The order of tables must be table_join_t2,table_join_t3:
explain select * from table_join_t2,table_join_t3 where table_join_t2.a < 200 and table_join_t2.b=table_join_t3.b;

drop table table_join_t1, table_join_t2, table_join_t3;

# BUG#14940 {Wrong query plan is chosen because of odd results of
# prev_record_reads() function }
create table table_join_t1 (a int); 
insert into table_join_t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);

create table table_join_t2 (a int, b int, primary key(a));
insert into table_join_t2 select @v:=A.a+10*B.a, @v  from table_join_t1 A, table_join_t1 B;

explain select * from table_join_t1;
show status like '%cost%';
select 'The cost of accessing table_join_t1 (dont care if it changes' '^';

select 'vv: Following query must use ALL(table_join_t1), eq_ref(A), eq_ref(B): vv' Z;

explain select * from table_join_t1, table_join_t2 a, table_join_t2 b where a.a = table_join_t1.a and b.a=a.b;
show status like '%cost%';
select '^^: The above should be ~= 20 + cost(select * from table_join_t1). Value less than 20 is an error' Z;



drop table table_join_t1, table_join_t2;

#
# Bug #31094: Forcing index-based sort doesn't work anymore if joins are
# done
#

CREATE TABLE table_join_t1 (a INT PRIMARY KEY, b INT);
CREATE TABLE table_join_t2 (c INT PRIMARY KEY, d INT);

INSERT INTO table_join_t1 VALUES(1,NULL),(2,NULL),(3,NULL),(4,NULL);
INSERT INTO table_join_t1 SELECT a + 4, b FROM table_join_t1;
INSERT INTO table_join_t1 SELECT a + 8, b FROM table_join_t1;
INSERT INTO table_join_t1 SELECT a + 16, b FROM table_join_t1;
INSERT INTO table_join_t1 SELECT a + 32, b FROM table_join_t1;
INSERT INTO table_join_t1 SELECT a + 64, b FROM table_join_t1;
INSERT INTO table_join_t2 SELECT a, b FROM table_join_t1;

#expect indexed ORDER BY
EXPLAIN SELECT * FROM table_join_t1 JOIN table_join_t2 ON b=c ORDER BY a LIMIT 2;
EXPLAIN SELECT * FROM table_join_t1 JOIN table_join_t2 ON a=c ORDER BY a LIMIT 2;
SELECT * FROM table_join_t1 JOIN table_join_t2 ON b=c ORDER BY a LIMIT 2;
SELECT * FROM table_join_t1 JOIN table_join_t2 ON a=c ORDER BY a LIMIT 2;

#expect filesort
EXPLAIN SELECT * FROM table_join_t1 JOIN table_join_t2 ON b=c ORDER BY a;
EXPLAIN SELECT * FROM table_join_t1 JOIN table_join_t2 ON a=c ORDER BY a;
SELECT * FROM table_join_t1 JOIN table_join_t2 ON b=c ORDER BY a;
SELECT * FROM table_join_t1 JOIN table_join_t2 ON a=c ORDER BY a;

DROP TABLE IF EXISTS table_join_t1,table_join_t2;


--echo #
--echo # Bug #42116: Mysql crash on specific query
--echo #
CREATE TABLE table_join_t1 (a INT);
CREATE TABLE table_join_t2 (a INT);
CREATE TABLE table_join_t3 (a INT, INDEX (a));
CREATE TABLE table_join_t4 (a INT);
CREATE TABLE table_join_t5 (a INT);
CREATE TABLE table_join_t6 (a INT);

INSERT INTO table_join_t1 VALUES (1), (1), (1);

INSERT INTO table_join_t2 VALUES
(2), (2), (2), (2), (2), (2), (2), (2), (2), (2);

INSERT INTO table_join_t3 VALUES
(3), (3), (3), (3), (3), (3), (3), (3), (3), (3);

EXPLAIN
SELECT * 
FROM 
  table_join_t1 JOIN table_join_t2 ON table_join_t1.a = table_join_t2.a 
  LEFT JOIN 
  (
   (
    table_join_t3 LEFT JOIN table_join_t4 ON table_join_t3.a = table_join_t4.a
   ) 
   LEFT JOIN 
   (
     table_join_t5 LEFT JOIN table_join_t6 ON table_join_t5.a = table_join_t6.a
   ) 
   ON table_join_t4.a = table_join_t5.a
  ) 
  ON table_join_t1.a = table_join_t3.a;

SELECT * 
FROM 
  table_join_t1 JOIN table_join_t2 ON table_join_t1.a = table_join_t2.a 
  LEFT JOIN 
  (
   (
    table_join_t3 LEFT JOIN table_join_t4 ON table_join_t3.a = table_join_t4.a
   ) 
   LEFT JOIN 
   (
     table_join_t5 LEFT JOIN table_join_t6 ON table_join_t5.a = table_join_t6.a
   ) 
   ON table_join_t4.a = table_join_t5.a
  ) 
  ON table_join_t1.a = table_join_t3.a;

DROP TABLE table_join_t1,table_join_t2,table_join_t3,table_join_t4,table_join_t5,table_join_t6;

--echo #
--echo # Bug#48483: crash in get_best_combination()
--echo #

CREATE TABLE table_join_t1(f1 INT);
INSERT INTO table_join_t1 VALUES (1),(2);
CREATE VIEW v1 AS SELECT 1 FROM table_join_t1 LEFT JOIN table_join_t1 AS table_join_t2 on 1=1;
EXPLAIN EXTENDED
SELECT 1 FROM v1 right join v1 AS v2 ON RAND();
DROP VIEW v1;
DROP TABLE table_join_t1;

--echo #
--echo # Bug#52177 crash with explain, row comparison, join, text field
--echo #
CREATE TABLE table_join_t1 (a TINYINT, b TEXT, KEY (a));
INSERT INTO table_join_t1 VALUES (0,''),(0,'');
FLUSH TABLES;
EXPLAIN SELECT 1 FROM table_join_t1 LEFT JOIN table_join_t1 a ON 1
WHERE ROW(table_join_t1.a, 1111.11) = ROW(1111.11, 1111.11) AND
ROW(table_join_t1.b, 1111.11) <=> ROW('','');
DROP TABLE table_join_t1;

--echo #
--echo # Bug #50335: Assertion `!(order->used & map)' in eq_ref_table
--echo # 

CREATE TABLE table_join_t1 (a INT NOT NULL, b INT NOT NULL, PRIMARY KEY (a,b));
INSERT INTO table_join_t1 VALUES (0,0), (1,1);

SELECT * FROM table_join_t1 STRAIGHT_JOIN table_join_t1 table_join_t2 ON table_join_t1.a=table_join_t2.a AND table_join_t1.a=table_join_t2.b ORDER BY table_join_t2.a, table_join_t1.a;

DROP TABLE table_join_t1;

--echo End of 5.0 tests.


#
# Bug#47150 Assertion in Field_long::val_int() on MERGE + TRIGGER + multi-table UPDATE
#
CREATE TABLE table_join_t1 (f1 int);

CREATE TABLE table_join_t2 (f1 int);
INSERT INTO table_join_t2  VALUES (1);
CREATE VIEW v1 AS SELECT * FROM table_join_t2;

PREPARE stmt FROM 'UPDATE table_join_t2 AS A NATURAL JOIN v1 B SET B.f1 = 1';
EXECUTE stmt;
EXECUTE stmt;

DEALLOCATE PREPARE stmt;

DROP VIEW v1;
DROP TABLE table_join_t1, table_join_t2;

#
# Bug#45195 valgrind warnings about uninitialized values in store_record_in_cache()
#
CREATE TABLE table_join_t1(a CHAR(9),b INT,KEY(b),KEY(a)) ENGINE=SequoiaDB;
CREATE TABLE table_join_t2(a CHAR(9),b INT,KEY(b),KEY(a)) ENGINE=SequoiaDB;
INSERT INTO table_join_t1 VALUES ('1',null),(null,null);
INSERT INTO table_join_t2 VALUES ('1',null),(null,null);
CREATE TABLE mm1(a CHAR(9),b INT,KEY(b),KEY(a))
ENGINE=SequoiaDB  UNION=(table_join_t1,table_join_t2);
SELECT table_join_t1.a FROM mm1,table_join_t1;
DROP TABLE table_join_t1, table_join_t2, mm1;

#--echo #
#--echo # Bug #55568: user variable assignments crash server when used within
#--echo #             query
#--echo #
#
#
# This test case is invalidated because of fix of bug 55531
# The reason is that {1} is not a valid geometric collection.
#
#CREATE TABLE table_join_t1 (a INT);

#INSERT INTO table_join_t1 VALUES (0), (1);

#let $i=2;
#while ($i)
#{
#  SELECT MULTIPOINT(
#    1,
#    (
#      SELECT MULTIPOINT(
#        MULTIPOINT(
#          1,
#          (SELECT COUNT(*) FROM (SELECT 1 FROM table_join_t1 GROUP BY a,a) d)
#        )
#      ) FROM table_join_t1
#    )
#  ) != COUNT(*) q FROM table_join_t1 GROUP BY a;
#  dec $i;
#}
#
#DROP TABLE table_join_t1;

--echo #
--echo # Bug #54468: crash after item's print() function when ordering/grouping 
--echo #             by subquery
--echo #

CREATE TABLE table_join_t1(a INT, b INT);
INSERT INTO table_join_t1 VALUES (), ();

SELECT 1 FROM table_join_t1
GROUP BY
GREATEST(table_join_t1.a,
         (SELECT 1 FROM
          (SELECT table_join_t1.b FROM table_join_t1,table_join_t1 table_join_t2
           ORDER BY table_join_t1.a, table_join_t1.a LIMIT 1) AS d)
        );

DROP TABLE table_join_t1;

--echo #
--echo # Bug #53544: Server hangs during JOIN query in stored procedure called
--echo #             twice in a row
--echo #

CREATE TABLE table_join_t1(c INT);

INSERT INTO table_join_t1 VALUES (1), (2);

PREPARE stmt FROM "SELECT table_join_t2.c AS f1 FROM table_join_t1 LEFT JOIN
                                        table_join_t1 table_join_t2 ON table_join_t1.c=table_join_t2.c RIGHT JOIN
                                        table_join_t1 table_join_t3 ON table_join_t1.c=table_join_t3.c 
                   GROUP BY f1;";

EXECUTE stmt;
EXECUTE stmt;

DEALLOCATE PREPARE stmt;
DROP TABLE table_join_t1;

--echo End of 5.1 tests

--echo #
--echo # Bug #59696 Optimizer fails to move WHERE condition on JOIN column 
--echo #            when joining with a view
--echo #

CREATE TABLE table_join_t1 (
  c1 INTEGER NOT NULL
);

INSERT INTO table_join_t1 VALUES (1),(2),(3);

CREATE TABLE table_join_t2 (
  pk INTEGER NOT NULL,
  c1 INTEGER NOT NULL,
  PRIMARY KEY (pk)
);

INSERT INTO table_join_t2 VALUES (1,4),(3,5),(2,6);

let $query=
SELECT table_join_t2.pk, table_join_t2.c1 FROM table_join_t2, table_join_t1 
WHERE table_join_t2.pk = table_join_t1.c1 AND table_join_t2.pk >= 2;

eval EXPLAIN $query;
eval $query;

# Create a view on one of the tables. The same query plan should
# be used when joining with this view as with the underlying table.
CREATE VIEW v_table_join_t2 AS SELECT * FROM table_join_t2;

let $query=
SELECT v_table_join_t2.pk, v_table_join_t2.c1 FROM v_table_join_t2, table_join_t1 
WHERE v_table_join_t2.pk = table_join_t1.c1 AND v_table_join_t2.pk >= 2;

eval EXPLAIN $query;
eval $query;

DROP VIEW v_table_join_t2;
DROP TABLE table_join_t1, table_join_t2;

--echo #
--echo # Bug 13102033 - CRASH IN COPY_FUNCS IN SQL_SELECT.CC ON JOIN + 
--echo #                GROUP BY + ORDER BY
--echo #

CREATE TABLE table_join_t1 (  
  pk INTEGER NOT NULL,
  i1 INTEGER NOT NULL,
  i2 INTEGER NOT NULL,
  PRIMARY KEY (pk)
);

INSERT INTO table_join_t1 VALUES (7,8,1), (8,2,2);

CREATE VIEW v1 AS SELECT * FROM table_join_t1;

let query=
SELECT table_join_t1.pk
FROM v1, table_join_t1
WHERE v1.i2 = 211
  AND v1.i2 > 7
  OR table_join_t1.i1 < 3
GROUP BY table_join_t1.pk
ORDER BY v1.i2;

--source suite/sequoiadb_query/include/turn_off_only_full_group_by.inc
eval EXPLAIN $query;
eval $query;
--source suite/sequoiadb_query/include/restore_sql_mode_after_turn_off_only_full_group_by.inc

let query=
SELECT table_join_t1.pk
FROM v1, table_join_t1
WHERE (v1.i2 = 211 AND v1.i2 > 7)
   OR (table_join_t1.i1 < 3 AND v1.i2 < 10);

eval EXPLAIN $query;
eval $query;

DROP VIEW v1;
DROP TABLE table_join_t1;

--echo #
--echo # BUG#11752239 - 43368: STRAIGHT_JOIN DOESN'T WORK FOR NESTED JOINS 
--echo #
create table table_join_t1(c1 int primary key, c2 char(10)) engine=sequoiadb;
create table table_join_t2(c1 int primary key, c2 char(10), ref_table_join_t1 int) engine=sequoiadb;
create table table_join_t3(c1 int primary key, c2 char(10), ref_table_join_t1 int) engine=sequoiadb;
create table table_join_t4(c1 int primary key, c2 char(10), ref_table_join_t1 int) engine=sequoiadb;
insert into table_join_t1 values(1,'a');
insert into table_join_t2 values(1,'a', 1);
insert into table_join_t3 values(1,'a', 1);
insert into table_join_t3 values(2,'b',2);
insert into table_join_t4 values(1,'a', 1);
insert into table_join_t4 values(2,'a', 2);
insert into table_join_t4 values(3,'a', 3);
insert into table_join_t4 values(4,'a', 4);
insert into table_join_t1 values(2,'b');
insert into table_join_t1 values(3,'c');

let $rest_of_query=(table_join_t1 join table_join_t3 on table_join_t3.ref_table_join_t1 =
table_join_t1.c1 join table_join_t2 on table_join_t2.ref_table_join_t1 = table_join_t1.c1) on table_join_t4.ref_table_join_t1 = table_join_t1.c1;

eval EXPLAIN SELECT * FROM table_join_t4 JOIN $rest_of_query;
eval EXPLAIN SELECT STRAIGHT_JOIN * FROM table_join_t4 JOIN $rest_of_query;
eval EXPLAIN SELECT * FROM table_join_t4 STRAIGHT_JOIN $rest_of_query;

drop table table_join_t1,table_join_t2,table_join_t3,table_join_t4;

--echo # Bug#20455184: Assertion failed: join_cond in optimizer.cc

CREATE TABLE table_join_t1(a INTEGER) engine=sequoiadb;

#let $query=
#SELECT 1
#FROM (SELECT 1 FROM table_join_t1 WHERE a) AS q
#     NATURAL LEFT JOIN table_join_t1
#     NATURAL LEFT JOIN table_join_t1 AS table_join_t2;

#eval explain $query;
#eval $query;

#let $query=
#SELECT 1
#FROM table_join_t1
#     NATURAL RIGHT JOIN table_join_t1 AS table_join_t2
#     NATURAL RIGHT JOIN (SELECT 1 FROM table_join_t1 WHERE a) AS q;

#eval explain $query;
#eval $query;

DROP TABLE table_join_t1;

--echo # Bug#21045724: Assertion '!table || !table->read_set ...

CREATE TABLE table_join_t1
(pk INTEGER,
 dummy VARCHAR(64),
 col_check TINYINT,
 PRIMARY KEY(pk)
) engine=sequoiadb;

INSERT INTO table_join_t1 VALUES (13, '13', 13);

CREATE VIEW v1 AS
SELECT *
FROM table_join_t1
WHERE pk BETWEEN 13 AND 14;

PREPARE stable_join_t1 FROM "
UPDATE v1 AS a NATURAL JOIN v1 AS b
SET a.dummy = '', b.col_check = NULL ";

EXECUTE stable_join_t1;
EXECUTE stable_join_t1;

DEALLOCATE PREPARE stable_join_t1;
DROP VIEW v1;
DROP TABLE table_join_t1;

--source suite/sequoiadb_query/include/uninstall_sequoiadb.inc
